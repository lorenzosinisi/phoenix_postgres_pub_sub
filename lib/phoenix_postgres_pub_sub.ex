defmodule PhoenixPostgresPubSub do
  use GenServer

  @moduledoc """
  # PhoenixPostgresPubSub

  Listen to changes to the tables of your Postgres database. For every INSERT or UPDATE in a specified table, a function will be called with the payload.

  ## Installation

  If [available in Hex](https://hex.pm/docs/publish), the package can be installed
  by adding `phoenix_postgres_pub_sub` to your list of dependencies in `mix.exs`:

  ```elixir
  def deps do
    [
      {:phoenix_postgres_pub_sub, "~> 0.1.0"}
    ]
  end
  ```

  ## Configuration

  In your config.exs add the following:

  ```elixir

    config :phoenix_postgres_pub_sub, :config,
      adapter: MainModuleOfYourApp, # this should be the main module of your phoenix application
      repo: MainModuleOfYourApp.Repo # and this should be the main repo of your phoenix application
  ```

  In your Application Module change the configuration in the following way:

  ```elixir
    defmodule MainModuleOfYourApp do

    use Application

    # See http://elixir-lang.org/docs/stable/elixir/Application.html
    # for more information on OTP Applications
    def start(_type, _args) do
      import Supervisor.Spec, warn: false

      children = [
        # Start the endpoint when the application starts
        supervisor(MainModuleOfYourApp.Endpoint, []),
        # Start the Ecto repository
        worker(MainModuleOfYourApp.Repo, []),
        worker(
          PhoenixPostgresPubSub,
          [
            [
              "skills_changes" # this should be always in the format NAME_OF_TABLE_changes,
              "users_changes" # this should be always in the format NAME_OF_TABLE_changes,
              "companies_changes" # this should be always in the format NAME_OF_TABLE_changes,
              ...
            ]
          ],
          restart: :permanent
        ),
        # Here you could define other workers and supervisors as children
        # worker(MainModuleOfYourApp.Worker, [arg1, arg2, arg3]),
      ]
  ```

  ## Generate the migration

  At this point you have to generate a migration to add the trigger to Postgres.
  You can do this by running the following command:

  ```
  mix phoenix_postgres_pub_sub.gen.channel CHOOSE_A_MIGRATION_NAME --table=users
  # check the migration file just generated and make your changes if necessary
  ```

  And run the migration with `mix ecto.migration`

  `--table` is the table upon which your want to listen to changes

  ## Generate your adapter

  Create a module called something like `MainModuleOfYourApp.PhoenixPostgresPubSub`.

  This module should have a function called `handle_postgres_notification` that accepts two arguments: notification, state

  The notification is the one generated by Postgres and sent to this function, while the state is the state of GenServer of PhoenixPostgresPubSub

  ## Test it out

  You you have followed all the steps correctly you should be able to make changes to the table on which your are listening to and you should see that the function `MainModuleOfYourApp.PhoenixPostgresPubSub.handle_postgres_notification/2` is called every time this happens.


  """

  @doc """
  Initialize the GenServer
  """
  @spec start_link(List.t()) :: {:ok, pid}
  def start_link(channels), do: GenServer.start_link(__MODULE__, channels, name: __MODULE__)

  @doc """
  When the GenServer starts subscribe to the given channel
  """
  @spec init(List.t()) :: {:ok, []}
  def init(channels) do
    pg_config = repo_from_config().config()
    {:ok, pid} = Postgrex.Notifications.start_link(pg_config)

    list_of_channels = List.wrap(channels)
    Enum.map(list_of_channels, fn channel -> Postgrex.Notifications.listen(pid, channel) end)

    {:ok, {pid, channels, nil}}
  end

  @doc """
  Listen for changes
  """
  def handle_info(notification, state) do
    adapter = Module.concat(adapter_from_config(), PhoenixPostgresPubSub)
    apply(adapter, :handle_postgres_notification, [notification, state])

    {:noreply, :event_handled}
  end

  defp adapter_from_config() do
    Application.get_env(:phoenix_postgres_pub_sub, :config)[:adapter]
  end

  defp repo_from_config() do
    Application.get_env(:phoenix_postgres_pub_sub, :config)[:repo]
  end
end
